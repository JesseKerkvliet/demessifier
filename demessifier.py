
#!/usr/bin/python


"""
This script cleans up after making a slurmy mess
This script has two steps: arming and cleaning.
During the arming step, a directory is created for your run and
the files to clean are tracked. During the cleaning step, done after your pipeline,
the tracked files are moved to the dedicated directory.
"""

# imports
import click
import subprocess
import logging
from datetime import date
import os
import sys
import re


def welcome(command):
    # Prints a welcome message depending on which part of the tool you run (TODO)
    print("Welcome to the Slurm Demessifier")

def findFiletypes(filelist):
    """
    Function interprets the list of files in the snapshot and determines which file extensions are present.
    Returns a unique list of file extensions.
    Some extensions are special cases. For now: gz can be anything just packed, so the extension before .gz is
    Just as relevant. Slurm "out" files are different from general "out" files (like BLAST outfiles) 
    and need to be placed together with the slurm output files. Slurm core files have the format core.[numbers]
    These core files need to be grouped together to be cleaned properly. 
    """

    # Switch dict for special cases. May be expanded along the way
    switch = {
    "gz":lambda x: (x.split(".")[-1] if len(x.split(".")) <= 2 else ".".join(x.split(".")[-2:])),
    "out" : lambda x: ("slurm" if re.search("slurm-.*\.out",x) else x.split(".")[-1]),
    "core": lambda x: (x.split(".")[0] if re.search("core.[0-9]*$",x) else x.split(".")[-1])
    }

    extensions = []
    # Slurm core files have a different format. This accounts for that
    for file in filelist:
        regex = "core.[0-9]*$" # core.23487
        if re.search(regex,file):
            ext = "core"
        else:
            ext = file.split(".")[-1]
        # If the extension is a special case, it gets the proper treatment. If not, it uses the default extension.
        extensions.append(switch.get(ext,lambda x: x.split(".")[-1])(file))
    return(list(set(extensions)))

def getRunName(outdir):
    """
    Function returns a runName based on today's date and generates a unique name if today's date is already taken.    
    """
    
    today=date.today()
    default_name="demessifier_{}_{}_{}".format(today.year,today.month,today.day)
    count = 1
    outname = default_name 

    while True:
        if os.path.isdir("{}/{}".format(outdir,outname)):
            outname = "{}_{}".format(default_name,count)
            count += 1
        else:
            break
    return(outname)

               
def writeToFile(dir,name, present_files):
    """
    Function writes a snapshot of the files present in the workdir to a arm-file
    """

    filename = "demessifier_armed_{}.txt".format(name)
    snapshot = ",".join(present_files)
    message = "run_name:{}\ndir:{}\nsnapshot:{}".format(name,dir,snapshot)
    with open(filename,'w') as outfile:
        outfile.write(message)    

def goodbye(status):
    # Returns exit message and exits
    ## TODO: add different actions for different exit statuses
    if status == 0:
	    print("Success! Thanks for using Demessifier!")
    if status == 1:
            print("Demessifier was unable to clean your workdir. Please check the error message and try again.")
    sys.exit()

# Add date and time to log messages
logging.basicConfig(
    level=logging.INFO,
    datefmt="%Y-%m-%d %H:%M",
    format="[%(asctime)s %(levelname)s] %(message)s",
)

@click.group()
def cligroup():
    """
    ### Demessifier ###\n
    This tool is designed to clean intermediary files and log files generated by pipelines or the SLURM job scheduler.\n
    The tool works in two stages: first arm the experiment by running demessifier.py arm (see demessifier.py arm --help for more information)\n
    Next, after running your pipeline(s) run demessifier.py clean (see demessifier.py clean --help for more information) to clean the mess.\n
    """


# First command to arm the tool
@cligroup.command(
    "arm",
    short_help="Arm the script before cleaning up"
)

# Name parameter
@click.option("-n",
    "--name",
    default=getRunName(dir),
    show_default=False,
    help="Give the run you want to log a name"
)

# Output dir parameter
@click.option("-d",
    "--dir",
    default="./demessifier_logs",
    type=click.Path(dir_okay=True, writable=True),
    help="Location to put the files"
)

def arm_demessifier(name, dir):
    """
    Function arms the tool. The output directories will be created and a snapshot of the workdir is 
    saved to use in the actual cleaning process. 
    """
    welcome("arm")
    # make output directory
    try:
        os.makedirs("{}/{}".format(dir,name))
    except FileExistsError:
        # If the user-given name already exists, the tool will use the date as name
        name = getRunName(dir)
       	print("Run name already exists in this directory. I'll use a generic name!\nYour files will be in {}/{}".format(dir,name))
        os.makedirs("{}/{}".format(dir,name))            

    # Make snapshot of files that already exist
    present_files = os.listdir(".")
    
    # Write snapshot to file
    writeToFile(dir,name,present_files)
    print("Arming succesful!") 
    goodbye(0)
    
# Second command to clean an armed job
@cligroup.command("clean")

# Cleaning option can be either slurm or full
@click.option(
"-c","--cleaning",
type=click.Choice(["slurm","full"],case_sensitive=False),default="slurm"
)

# Mandatory parameter for run name
@click.option(
"-n","--name", required=True
)

def clean(name,cleaning):
    """
    Function cleans the specified armed run.
    """

    welcome("clean")

    # Check if the armed experiment exists
    try:
        recover = open('demessifier_armed_{}.txt'.format(name),'r').read().splitlines()
    except FileNotFoundError:
        print("The file containing the run information could not be found. Please make sure you run this in the same directory as the armed file, or try arming a new experiment")
        goodbye(1)

    # The saved format is like a dictionary (: separated) and needs to be rebuilt.
    recov_list = [[x.split(':') for x in recover]]
    recov_dict = {}
    for entry in recov_list:
        recov_dict.update(dict(entry))
    name,dir,snapshot= "","",""

    # Sanity check to see if the files are unchanged: assigning the dict keys should work.
    try:
        name = recov_dict['run_name']
        dir = recov_dict['dir']
        snapshot = recov_dict['snapshot'].split(',')
    except KeyError:
        print('Something went wrong. Please make sure the demessifier_armed file was not changed after arming.')
        goodbye(1)


    # Subtracting files already there from the files currently there
    current_files = os.listdir('.')
    newfiles = list(set(current_files) - set(snapshot))

    # The mode of cleaning determines which filetypes need to be cleaned
    if cleaning == "slurm":
        filetypes = ["slurm","core"]

    else:
        filetypes = findFiletypes(newfiles)

    for type in filetypes:
        # Dict for special cases
        typedict = {
        "slurm": "slurm-.*out$",
        "core": "core.[0-9]*$",
        "default": ".{}$"
        }
        
        # Either get a special case regex, or the default
        regex = typedict.get(type, typedict.get("default")).format(type)
        
        indices = [i for i,x in enumerate(newfiles) if re.search(regex,x)]

        # Try to make a directory for each filetype
        try:
            os.makedirs("{}/{}/{}".format(dir,name,type))
        except FileExistsError:
            # Check to see if the sample has already been cleaned or if something went wrong 
            if os.path.exists("{}/{}/done.txt".format(dir,name)):
                print("It looks like this mess is cleaned already! Please check your given name or try arming a new experiment")
            else:
                print("It looks like something went wrong. Cleaning has failed. Please try arming a new experiment")
            goodbye(1)

        
        files = [newfiles[i] for i in indices]

        # Move the files
        for file in files:
            os.rename("./{}".format(file), "{}/{}/{}/{}".format(dir,name,type,file))
    
    # Create Done file
    open('{}/{}/done.txt'.format(dir,name),'w').close()             
    goodbye(0)

# Test command for debug purposes
"""
@cligroup.command("test")
def test():
    testlist = ["a.txt","b.fasta","slurm-123489.out","123489.core","b.txt","c.fastq.gz","d.tar.gz","e.gz","blast.out","core.19827"]
"""

if __name__ == "__main__":
    cligroup()
